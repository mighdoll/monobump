#!/usr/bin/env node
import fs, { realpath } from "node:fs/promises";
import path from "node:path";
import { exec } from "node:child_process";
import { parseArgs, promisify } from "node:util";
import { fileURLToPath } from "node:url";
import { existsSync, readdirSync } from "node:fs";

//#region src/Bump.ts
/** Prerelease type with prefix mapping */
const prereleasePrefix = {
	alpha: "a",
	beta: "b",
	rc: "rc"
};
/** Parse a version string into components */
function parseVersion(version) {
	const match = version.match(/^(\d+)\.(\d+)\.(\d+)(?:-(a|b|rc)(\d+))?$/);
	if (!match) throw new Error(`Invalid version: ${version}`);
	const [, major, minor, patch, preType, preNum] = match;
	const result = {
		major: Number(major),
		minor: Number(minor),
		patch: Number(patch)
	};
	if (preType) result.prerelease = {
		type: {
			a: "alpha",
			b: "beta",
			rc: "rc"
		}[preType],
		num: Number(preNum)
	};
	return result;
}
/** Format a parsed version back to string */
function formatVersion(v) {
	const base = `${v.major}.${v.minor}.${v.patch}`;
	if (v.prerelease) return `${base}-${prereleasePrefix[v.prerelease.type]}${v.prerelease.num}`;
	return base;
}
/** Bump a semver version */
function bumpVersion(version, type) {
	const v = parseVersion(version);
	if (type === "major" || type === "minor" || type === "patch") {
		if (v.prerelease) {
			delete v.prerelease;
			if (type === "minor") {
				v.minor++;
				v.patch = 0;
			} else if (type === "major") {
				v.major++;
				v.minor = 0;
				v.patch = 0;
			}
			return formatVersion(v);
		}
		switch (type) {
			case "major": return `${v.major + 1}.0.0`;
			case "minor": return `${v.major}.${v.minor + 1}.0`;
			case "patch": return `${v.major}.${v.minor}.${v.patch + 1}`;
		}
	}
	const prereleaseType = type;
	if (v.prerelease) if (v.prerelease.type === prereleaseType) v.prerelease.num++;
	else v.prerelease = {
		type: prereleaseType,
		num: 1
	};
	else {
		v.minor++;
		v.patch = 0;
		v.prerelease = {
			type: prereleaseType,
			num: 1
		};
	}
	return formatVersion(v);
}
/** Update version in a package.json file */
async function updatePackageVersion(packagePath, newVersion) {
	const packageJsonPath = path.join(packagePath, "package.json");
	const content = await fs.readFile(packageJsonPath, "utf-8");
	const packageJson = JSON.parse(content);
	packageJson.version = newVersion;
	await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2) + "\n");
}
/** Bump versions for all packages in the toBump set */
async function bumpPackages(packages, toBump, reasons, type, dryRun = false) {
	const results = [];
	for (const pkg of packages) {
		if (!toBump.has(pkg.name)) continue;
		const oldVersion = pkg.version;
		const newVersion = bumpVersion(oldVersion, type);
		const reason = reasons.get(pkg.name) || "changed";
		if (!dryRun) await updatePackageVersion(pkg.path, newVersion);
		results.push({
			package: pkg.name,
			oldVersion,
			newVersion,
			reason
		});
	}
	return results;
}

//#endregion
//#region src/Cascade.ts
/** Build dependency graph by reading package.json files */
async function buildDependencyGraph(packages) {
	const graph = /* @__PURE__ */ new Map();
	for (const pkg of packages) {
		const dependencies = await getWorkspaceDeps(pkg.path);
		graph.set(pkg.name, {
			...pkg,
			dependencies
		});
	}
	return graph;
}
async function getWorkspaceDeps(pkgPath) {
	const packageJsonPath = path.join(pkgPath, "package.json");
	const content = await fs.readFile(packageJsonPath, "utf-8");
	const packageJson = JSON.parse(content);
	const dependencies = /* @__PURE__ */ new Set();
	for (const section of [
		"dependencies",
		"devDependencies",
		"peerDependencies"
	]) if (packageJson[section]) {
		for (const [depName, depVersion] of Object.entries(packageJson[section])) if (typeof depVersion === "string" && depVersion.startsWith("workspace:")) dependencies.add(depName);
	}
	return dependencies;
}
/** Find all packages that depend on the given packages (recursively) */
function findDependents(graph, changedPackages) {
	const allAffected = new Set(changedPackages);
	const dependencyReasons = /* @__PURE__ */ new Map();
	let hasChanges = true;
	while (hasChanges) {
		hasChanges = false;
		for (const [pkgName, pkg] of graph.entries()) {
			if (allAffected.has(pkgName)) continue;
			const affectedDep = findAffectedDependency(pkg.dependencies, allAffected);
			if (affectedDep) {
				allAffected.add(pkgName);
				dependencyReasons.set(pkgName, affectedDep);
				hasChanges = true;
			}
		}
	}
	return {
		allAffected,
		dependencyReasons
	};
}
function findAffectedDependency(dependencies, affected) {
	for (const dep of dependencies) if (affected.has(dep)) return dep;
	return null;
}
/** Get packages to bump: changed packages + their dependents, excluding private packages */
async function getPackagesToBump(packages, changedPackages) {
	const publicPackages = packages.filter((pkg) => !pkg.private);
	const publicPackageNames = new Set(publicPackages.map((pkg) => pkg.name));
	const changedPublicPackages = new Set([...changedPackages].filter((name) => publicPackageNames.has(name)));
	const { allAffected, dependencyReasons } = findDependents(await buildDependencyGraph(publicPackages), changedPublicPackages);
	return {
		toBump: allAffected,
		reasons: buildReasonStrings(allAffected, changedPublicPackages, dependencyReasons)
	};
}
function buildReasonStrings(affected, changed, depReasons) {
	const reasons = /* @__PURE__ */ new Map();
	for (const pkgName of affected) if (changed.has(pkgName)) reasons.set(pkgName, "changed");
	else {
		const chain = buildDependencyChain(pkgName, depReasons);
		reasons.set(pkgName, `depends on ${chain.join(" -> ")}`);
	}
	return reasons;
}
function buildDependencyChain(pkgName, depReasons) {
	const chain = [];
	let current = pkgName;
	while (depReasons.has(current)) {
		const dep = depReasons.get(current);
		chain.push(dep);
		current = dep;
	}
	return chain;
}

//#endregion
//#region src/Detect.ts
const exec$3 = promisify(exec);
/** Find the last release commit (matching "chore: release") */
async function findLastReleaseCommit(cwd = process.cwd()) {
	try {
		const { stdout } = await exec$3("git log --oneline --grep=\"chore: release\" -1", { cwd });
		const match = stdout.trim().match(/^([a-f0-9]+)/);
		return match ? match[1] : null;
	} catch {
		return null;
	}
}
/** Get all files changed since a specific commit */
async function getChangedFiles(since, cwd = process.cwd()) {
	const { stdout } = await exec$3(`git diff --name-only ${since ? `${since}..HEAD` : `$(git rev-list --max-parents=0 HEAD)..HEAD`}`, { cwd });
	return stdout.trim().split("\n").filter(Boolean);
}
/** Get commit history for changed files since last release */
async function getCommitHistory(since, cwd = process.cwd()) {
	const { stdout } = await exec$3(`git log --oneline ${since ? `${since}..HEAD` : `$(git rev-list --max-parents=0 HEAD)..HEAD`}`, { cwd });
	return stdout.trim().split("\n").filter(Boolean).map(parseCommitLine).filter((commit) => commit !== null);
}
/** Get commits that touched specific files/directories */
async function getCommitsForPaths(paths, since, cwd = process.cwd()) {
	if (paths.length === 0) return [];
	const { stdout } = await exec$3(`git log --oneline ${since ? `${since}..HEAD` : `$(git rev-list --max-parents=0 HEAD)..HEAD`} -- ${paths.join(" ")}`, { cwd });
	return stdout.trim().split("\n").filter(Boolean).map(parseCommitLine).filter((commit) => commit !== null);
}
function parseCommitLine(line) {
	const match = line.match(/^([a-f0-9]+)\s+(.+)$/);
	return match ? {
		hash: match[1],
		message: match[2]
	} : null;
}
/** Map changed files to packages */
async function mapFilesToPackages(changedFiles, packages, cwd = process.cwd()) {
	const sortedPackages = sortByDepth(await normalizePackagePaths(packages));
	const changedPackages = /* @__PURE__ */ new Set();
	for (const file of changedFiles) {
		const absoluteFile = await resolveFilePath(cwd, file);
		if (!absoluteFile) continue;
		const pkg = findMatchingPackage(absoluteFile, sortedPackages);
		if (pkg) changedPackages.add(pkg);
	}
	return changedPackages;
}
async function normalizePackagePaths(packages) {
	return Promise.all(packages.map(async (pkg) => ({
		name: pkg.name,
		realPath: await realpath(pkg.path)
	})));
}
function sortByDepth(packages) {
	return packages.sort((a, b) => {
		const depthA = path.normalize(a.realPath).split(path.sep).length;
		return path.normalize(b.realPath).split(path.sep).length - depthA;
	});
}
async function resolveFilePath(cwd, file) {
	try {
		return await realpath(path.resolve(cwd, file));
	} catch {
		return null;
	}
}
function findMatchingPackage(absoluteFile, packages) {
	for (const pkg of packages) if (absoluteFile.startsWith(pkg.realPath + path.sep) || absoluteFile === pkg.realPath) return pkg.name;
	return null;
}
/** Detect which packages have changes since last release */
async function detectChangedPackages(packages, cwd = process.cwd()) {
	const lastRelease = await findLastReleaseCommit(cwd);
	const changedFiles = await getChangedFiles(lastRelease, cwd);
	const commits = await getCommitHistory(lastRelease, cwd);
	return {
		changed: await mapFilesToPackages(changedFiles, packages, cwd),
		commits
	};
}

//#endregion
//#region src/Changelog.ts
/** Generate changelog showing commits per package and dependency updates */
async function formatChangelog(results, packages, cwd) {
	if (results.length === 0) return "No packages to bump.\n";
	const packageMap = new Map(packages.map((p) => [p.name, p]));
	const resultMap = new Map(results.map((r) => [r.package, r]));
	const lastRelease = await findLastReleaseCommit(cwd);
	let output = "";
	for (const result of results) {
		output += `## ${result.package}\n`;
		if (result.reason === "changed") {
			const pkg = packageMap.get(result.package);
			if (pkg) {
				const commits = await getCommitsForPaths([pkg.path], lastRelease, cwd);
				for (const commit of commits) output += `- ${commit.hash} ${commit.message}\n`;
			}
		} else {
			const depName = extractDependencyName(result.reason);
			const depResult = resultMap.get(depName);
			if (depResult) output += `- Dependency: ${depName} ${depResult.newVersion}\n`;
		}
		output += "\n";
	}
	return output;
}
function extractDependencyName(reason) {
	const match = reason.match(/depends on (.+?)( ->|$)/);
	return match ? match[1] : "";
}
/** Format bump results for display */
function formatResults(results) {
	if (results.length === 0) return "No packages to bump.";
	let output = "\nPackages to bump:\n\n";
	for (const result of results) {
		const icon = result.reason === "changed" ? "*" : "^";
		output += `  ${icon} ${result.package}: ${result.oldVersion} -> ${result.newVersion} (${result.reason})\n`;
	}
	return output;
}

//#endregion
//#region src/Cli.ts
/** Parse command line arguments and return options */
async function parseCliArgs() {
	const { values } = parseArgs({
		options: {
			type: {
				type: "string",
				short: "t",
				default: "patch"
			},
			"dry-run": {
				type: "boolean",
				default: false
			},
			changelog: {
				type: "boolean",
				default: false
			},
			commit: {
				type: "boolean",
				default: true
			},
			tag: {
				type: "boolean",
				default: true
			},
			push: {
				type: "boolean",
				default: false
			},
			verbose: {
				type: "boolean",
				short: "v",
				default: false
			},
			version: {
				type: "boolean",
				default: false
			},
			help: {
				type: "boolean",
				short: "h",
				default: false
			}
		},
		allowPositionals: true,
		allowNegative: true
	});
	if (values.version) {
		const scriptDir = path.dirname(fileURLToPath(import.meta.url));
		const pkgPath = path.join(scriptDir, "..", "package.json");
		const pkg = JSON.parse(await fs.readFile(pkgPath, "utf-8"));
		console.log(pkg.version);
		process.exit(0);
	}
	if (values.help) {
		printHelp();
		process.exit(0);
	}
	const type = values.type;
	if (![
		"major",
		"minor",
		"patch",
		"alpha",
		"beta",
		"rc"
	].includes(type)) {
		console.error(`Invalid bump type: ${type}. Must be major, minor, patch, alpha, beta, or rc.`);
		process.exit(1);
	}
	return {
		type,
		dryRun: values["dry-run"],
		changelog: values.changelog,
		commit: values.commit,
		tag: values.tag,
		push: values.push,
		verbose: values.verbose
	};
}
function printHelp() {
	console.log(`
monobump - Smart version bumping for pnpm monorepos

Usage: monobump [options]

Options:
  -t, --type <type>      Bump type: major, minor, patch, alpha, beta, rc (default: patch)
  --dry-run              Show what would be bumped without making changes
  --changelog            Output changelog markdown grouped by package
  --commit, --no-commit  Create a git commit (default: true)
  --tag, --no-tag        Create git tags (default: true)
  --push                 Push commit and tags to remote
  -v, --verbose          Show verbose output
  -V, --version          Show version number
  -h, --help             Show this help message

Prerelease behavior:
  alpha/beta/rc from stable    Bumps minor, starts prerelease (0.7.0 -> 0.8.0-a1)
  alpha/beta/rc from same      Increments number (0.7.0-a1 -> 0.7.0-a2)
  alpha/beta/rc from different Starts new prerelease (0.7.0-a2 -> 0.7.0-b1)
  patch/minor/major from pre   Graduates to stable (0.7.0-a1 -> 0.7.0)

Examples:
  monobump                          # Bump patch version
  monobump --type minor --dry-run   # Preview minor version bump
  monobump --type alpha             # Start or increment alpha prerelease
  monobump --changelog              # Bump and output changelog
  monobump --push                   # Bump, commit, tag, and push
`);
}

//#endregion
//#region src/Git.ts
const exec$2 = promisify(exec);
/** Find the git root directory */
async function findGitRoot(cwd = process.cwd()) {
	const { stdout } = await exec$2("git rev-parse --show-toplevel", { cwd });
	return stdout.trim();
}
/** Create a git commit */
async function createCommit(message, cwd = process.cwd()) {
	await exec$2("git add .", { cwd });
	await exec$2(`git commit -m "${message}"`, { cwd });
}
/** Create a git tag */
async function createTag(tag, cwd = process.cwd()) {
	await exec$2(`git tag "${tag}"`, { cwd });
}
/** Push commits and tags to remote */
async function push(includeTags = false, cwd = process.cwd()) {
	await exec$2(`git push ${includeTags ? "--follow-tags" : ""}`.trim(), { cwd });
}

//#endregion
//#region src/Pnpm.ts
const exec$1 = promisify(exec);
/** Find pnpm workspace root by looking for pnpm-workspace.yaml */
function findWorkspaceRoot(startDir) {
	let currentDir = startDir;
	while (currentDir !== path.parse(currentDir).root) {
		if (existsSync(path.join(currentDir, "pnpm-workspace.yaml"))) return currentDir;
		currentDir = path.dirname(currentDir);
	}
	try {
		const entries = readdirSync(startDir, { withFileTypes: true });
		for (const entry of entries) if (entry.isDirectory()) {
			const subdirPath = path.join(startDir, entry.name);
			if (existsSync(path.join(subdirPath, "pnpm-workspace.yaml"))) return subdirPath;
		}
	} catch {}
	return startDir;
}
/** Get all workspace packages using pnpm */
async function findWorkspacePackages(cwd = process.cwd()) {
	const { stdout } = await exec$1("pnpm list --json --recursive --only-projects", { cwd: findWorkspaceRoot(cwd) });
	return parseWorkspaceJson(stdout).filter((pkg) => pkg.name).map((pkg) => ({
		name: pkg.name,
		version: pkg.version || "0.0.0",
		path: pkg.path,
		private: pkg.private
	}));
}
/** Parse output from 'pnpm list --json' */
function parseWorkspaceJson(stdout) {
	const arrayMatches = [...stdout.trim().matchAll(/\[[\s\S]*?\](?=\s*\[|$)/g)];
	if (arrayMatches.length > 1) throw new Error(`pnpm output contains ${arrayMatches.length} JSON arrays. This indicates pnpm was not run from the workspace root. Ensure pnpm-workspace.yaml exists in your repository.`);
	if (arrayMatches.length === 0) throw new Error("pnpm output is empty or invalid");
	try {
		return JSON.parse(arrayMatches[0][0]);
	} catch (error) {
		console.error("Failed to parse pnpm output:", arrayMatches[0][0].slice(0, 200));
		throw error;
	}
}

//#endregion
//#region src/main.ts
main();
async function main() {
	const options = await parseCliArgs();
	try {
		await runBump(options);
	} catch (error) {
		console.error("Error:", error instanceof Error ? error.message : String(error));
		process.exit(1);
	}
}
async function runBump(options) {
	const gitRoot = await findGitRoot();
	const workspaceCwd = process.cwd();
	logVerbose(options.verbose, "Options:", options);
	logVerbose(options.verbose, "Git root:", gitRoot);
	logVerbose(options.verbose, "Workspace directory:", workspaceCwd);
	logVerbose(options.verbose, "Discovering packages...");
	const packages = await findWorkspacePackages(workspaceCwd);
	const publicCount = packages.filter((p) => !p.private).length;
	logVerbose(options.verbose, `Found ${packages.length} packages (${publicCount} public)`);
	logVerbose(options.verbose, "Detecting changes since last release...");
	const { changed } = await detectChangedPackages(packages, gitRoot);
	logVerbose(options.verbose, `Changed packages: ${Array.from(changed).join(", ")}`);
	if (changed.size === 0) {
		console.log("No changes detected. Nothing to bump!");
		return;
	}
	logVerbose(options.verbose, "Computing dependency cascade...");
	const { toBump, reasons } = await getPackagesToBump(packages, changed);
	if (toBump.size === 0) {
		console.log("No public packages affected. Nothing to bump!");
		return;
	}
	const results = await bumpPackages(packages, toBump, reasons, options.type, options.dryRun);
	await displayResults(results, packages, options, gitRoot);
	if (!options.dryRun && options.commit) await performGitOps(results, options, gitRoot);
}
async function displayResults(results, packages, options, cwd) {
	console.log(formatResults(results));
	if (options.changelog) {
		console.log("\nChangelog:\n");
		const changelog = await formatChangelog(results, packages, cwd);
		console.log(changelog);
	}
	if (options.dryRun) console.log("\nDry run - no changes made.");
}
async function performGitOps(results, options, cwd) {
	if (results.length === 0) return;
	const commitMessage = new Set(results.map((r) => r.newVersion)).size === 1 ? `chore: release v${results[0].newVersion}` : `chore: release ${results.map((r) => `${r.package}@${r.newVersion}`).join(", ")}`;
	console.log("\nCreating commit...");
	await createCommit(commitMessage, cwd);
	if (options.tag) for (const result of results) {
		const tag = `${result.package}@${result.newVersion}`;
		console.log(`Creating tag ${tag}...`);
		await createTag(tag, cwd);
	}
	if (options.push) {
		console.log("Pushing to remote...");
		await push(options.tag, cwd);
	}
}
function logVerbose(verbose, ...args) {
	if (verbose) console.log(...args);
}

//#endregion
export { main };